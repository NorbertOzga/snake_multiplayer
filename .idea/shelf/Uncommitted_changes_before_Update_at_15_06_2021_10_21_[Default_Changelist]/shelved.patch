Index: src/server/server.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import socket\r\nfrom datetime import datetime\r\nimport random\r\nimport time\r\n\r\n\r\nclass UDPServer:\r\n    games = {}  # list of current games\r\n    users = {}  # \"IP\": \"user ID\"\r\n    game_shape = (25, 25)\r\n\r\n    def __init__(self, host, port):\r\n        self.host = host\r\n        self.port = port\r\n        self.sock = None  # Connection socket\r\n\r\n    def printwt(self, msg):\r\n        ''' Print message with current date and time '''\r\n\r\n        current_date_time = datetime.now().strftime('%Y-%m-%d %H:%M:%S')\r\n        print(f'[{current_date_time}] {msg}')\r\n\r\n    def configure_server(self):\r\n        ''' Configure the server '''\r\n        # create UDP socket with IPv4 addressing\r\n\r\n        self.printwt('Creating socket...')\r\n        self.printwt('Socket created')\r\n        # bind server to the address\r\n        self.sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\r\n        self.printwt(f'Binding server to {self.host}:{self.port}...')\r\n        self.sock.bind((self.host, self.port))\r\n        self.printwt(f'Server binded to {self.host}:{self.port}')\r\n\r\n    def handle_request(self, data, client_address):\r\n\r\n        ''' Handle the client '''\r\n        # handle request\r\n\r\n        req = data.decode('utf-8')\r\n        self.printwt(f'[ REQUEST from {client_address} ]')\r\n        print('\\n', req, '\\n')\r\n\r\n        req = eval(req)\r\n        if req[\"message_type\"] == 1:\r\n            resp = self.register_user(req)\r\n        elif req[\"message_type\"] == 3:\r\n            resp = self.list_games(req)\r\n        elif req[\"message_type\"] == 5:\r\n            resp = self.create_game(req)\r\n        elif req[\"message_type\"] == 7:\r\n            resp = self.join_game(req)\r\n        elif req[\"message_type\"] == 9:\r\n            resp = self.exit_game(req)\r\n        elif req[\"message_type\"] == 11:\r\n            resp = self.store_move(req)\r\n            resp = self.game_state(req)\r\n        else:\r\n            resp = {\r\n                \"sender\": 0,\r\n                \"message_type\": 12}\r\n        # send response to the client\r\n        resp = str(resp)\r\n        self.printwt(f'[ RESPONSE to {client_address} ]')\r\n        self.sock.sendto(resp.encode('utf-8'), client_address)\r\n\r\n        print('\\n', resp, '\\n')\r\n\r\n    def wait_for_client(self):\r\n        \"\"\" Wait for a client \"\"\"\r\n        try:\r\n            # receive message from a client\r\n\r\n            data, client_address = self.sock.recvfrom(1024)\r\n            # handle client's request\r\n\r\n            self.handle_request(data, client_address)\r\n        except OSError as err:\r\n            self.printwt(err)\r\n\r\n    def shutdown_server(self):\r\n        \"\"\" Shutdown the server \"\"\"\r\n\r\n        self.printwt('Shutting down server...')\r\n        self.sock.close()\r\n\r\n    def register_user(self, req):\r\n        nickname = req[\"nickname\"]\r\n        if nickname not in self.users.values():\r\n            user_id = self.get_new_user_id()\r\n            if user_id != -1:\r\n                self.users[user_id] = nickname\r\n                return {\r\n                    \"sender\": 0,\r\n                    \"message_type\": 2,\r\n                    \"response\": 200,\r\n                    \"user_id\": user_id\r\n                }\r\n\r\n        return {\r\n            \"sender\": 0,\r\n            \"message_type\": 2,\r\n            \"response\": 500\r\n        }\r\n\r\n    def list_games(self, req):\r\n        if req[\"user_id\"] not in self.users.keys():\r\n            return {\r\n                \"sender\": 0,\r\n                \"message_type\": 4,\r\n                \"success\": 500\r\n            }\r\n\r\n        game_info_list = []\r\n        for game_id in self.games:\r\n            can_join = 1 if self.games[game_id][\"players_num\"] < 2 else 0\r\n            game_name = self.games[game_id][\"game_name\"]\r\n            game_info_list.append([game_id, can_join, len(game_name), game_name])\r\n\r\n        return {\r\n            \"sender\": 0,\r\n            \"message_type\": 4,\r\n            \"number_of_games\": len(game_info_list),\r\n            \"list_of_games\": game_info_list,\r\n            \"success\": 200\r\n        }\r\n\r\n    def join_game(self, req):\r\n        game_id = req[\"game_id\"]\r\n        if self.games[game_id][\"players_num\"] < 2:\r\n            if self.games[game_id][\"player_1\"] == \"\":\r\n                self.games[game_id][\"player_1\"] = self.users[req[\"user_id\"]]\r\n                self.games[game_id][\"p1\"].append([5, 5])\r\n            else:\r\n                self.games[game_id][\"player_2\"] = self.users[req[\"user_id\"]]\r\n                self.games[game_id][\"p2\"].append([15, 15])\r\n\r\n            self.games[game_id][\"players_num\"] += 1\r\n\r\n            return {\r\n                \"sender\": 0,\r\n                \"message_type\": 8,\r\n                \"response\": 200,\r\n            }\r\n        else:\r\n            return {\r\n                \"sender\": 0,\r\n                \"message_type\": 8,\r\n                \"response\": 500,\r\n            }\r\n\r\n    def exit_game(self, req):\r\n        game_id = req[\"game_id\"]\r\n\r\n        if self.games[game_id][\"player_1\"] == self.users[req[\"user_id\"]]:\r\n            self.games[game_id][\"player_1\"] = \"\"\r\n        else:\r\n            self.games[game_id][\"player_2\"] = \"\"\r\n\r\n        self.games[game_id][\"players_num\"] -= 1\r\n\r\n        return {\r\n            \"sender\": 0,\r\n            \"message_type\": 10,\r\n            \"response\": 200,\r\n        }\r\n\r\n    def game_state(self, req):\r\n        if req[\"game_id\"] in self.games.keys():\r\n            return {\r\n                \"sender\": 0,\r\n                \"message_type\": 12,\r\n                \"game_state\": self.games[req[\"game_id\"]],\r\n                \"success\": 200\r\n            }\r\n        else:\r\n            return {\r\n                \"sender\": 0,\r\n                \"message_type\": 12,\r\n                \"success\": 500\r\n            }\r\n\r\n    def create_game(self, req):\r\n        game_id = self.get_new_game_id()\r\n        if game_id != -1:\r\n            self.games[game_id] = {\r\n                \"game_name\": req[\"game_name\"],\r\n                \"players_num\": 0,\r\n                \"player_1\": \"\",\r\n                \"player_2\": \"\",\r\n                \"d1\": \"\",\r\n                \"d2\": \"\",\r\n                \"snake1\": [],\r\n                \"snake2\": [],\r\n                \"food\": (10, 10)\r\n            }\r\n            return {\r\n                \"sender\": 0,\r\n                \"message_type\": 6,\r\n                \"response\": 200,\r\n                \"game_id\": game_id\r\n            }\r\n        else:\r\n            return {\r\n                \"sender\": 0,\r\n                \"message_type\": 6,\r\n                \"response\": 500\r\n            }\r\n\r\n    def get_new_game_id(self):\r\n        games_ids = self.games.keys()\r\n        for new_game_id in range(10000, 2 ** 16):\r\n            if new_game_id not in games_ids:\r\n                return new_game_id\r\n\r\n        return -1\r\n\r\n    def get_new_user_id(self):\r\n        users_ids = self.users.keys()\r\n        for new_user_id in range(10000, 2 ** 16):\r\n            if new_user_id not in users_ids:\r\n                return new_user_id\r\n\r\n        return -1\r\n\r\n    def store_move(self, req):\r\n        game_id = req[\"game_id\"]\r\n        current_game = self.games[game_id]\r\n        if current_game[\"player1\"] == self.users[req[\"user_id\"]]:\r\n            if not self.direction_problem(current_game[\"d1\"], req[\"d\"]):\r\n                current_game[\"d1\"] = req[\"d\"]\r\n        elif current_game[\"player2\"] == self.users[req[\"user_id\"]]:\r\n            if not self.direction_problem(current_game[\"d2\"], req[\"d\"]):\r\n                current_game[\"d2\"] = req[\"d\"]\r\n        else:\r\n            return {\r\n                \"success\": 500\r\n            }\r\n\r\n        return {\r\n            \"sucess\": 200\r\n        }\r\n\r\n    @staticmethod\r\n    def direction_problem(old_direction, new_direction):\r\n        if (old_direction == \"u\" and new_direction == \"d\") or (old_direction == \"d\" and new_direction == \"u\"):\r\n            return False\r\n        elif (old_direction == \"r\" and new_direction == \"l\") or (old_direction == \"l\" and new_direction == \"r\"):\r\n            return False\r\n        return True\r\n\r\n    def process_game(self, game_id):\r\n\r\n        curr_game = self.games[game_id]\r\n        s1 = curr_game[\"snake1\"]\r\n        s2 = curr_game[\"snake2\"]\r\n        d1 = curr_game[\"d1\"]\r\n        d2 = curr_game[\"d2\"]\r\n        food = curr_game[\"food\"]\r\n\r\n        p1_eat_food, p2_eat_food, new_food = self.check_food(s1, s2, food)\r\n\r\n        if s1:\r\n            s1 = self.move_snake(s1, d1, p1_eat_food)\r\n        if s2:\r\n            s2 = self.move_snake(s2, d2, p2_eat_food)\r\n\r\n        p1_collision, p2_collision = self.check_collisions(s1, s2)\r\n\r\n        curr_game[\"p1\"] = s1\r\n        curr_game[\"p2\"] = s2\r\n        curr_game[\"food\"] = new_food\r\n        curr_game[\"p1_game_over\"] = p1_collision\r\n        curr_game[\"p2_game_over\"] = p2_collision\r\n\r\n        self.games[game_id] = curr_game\r\n\r\n    @staticmethod\r\n    def move(point, direction):\r\n        if direction == \"u\":\r\n            return point[0]+1, point[1]\r\n        elif direction == \"d\":\r\n            return point[0]-1, point[1]\r\n        elif direction == \"r\":\r\n            return point[0], point[1]+1\r\n        elif direction == \"l\":\r\n            return point[0], point[1]-1\r\n\r\n    def move_snake(self, snake, direction, eat_food):\r\n\r\n        new_head = self.move(snake[0], direction)\r\n        snake.insert(0, new_head)\r\n\r\n        if not eat_food:\r\n            snake = snake[:-1]\r\n\r\n        return snake\r\n\r\n    def check_collisions(self, s1, s2):\r\n        p1_collision, p2_collision = 0, 0\r\n        if s1:\r\n            if s1[0][0] < 0 or s1[0][0] > self.game_shape[0] or s1[0][1] < 0 or s1[0][1] > self.game_shape[1]:\r\n                p1_collision = 1\r\n        if s2:\r\n            if s2[0][0] < 0 or s2[0][0] > self.game_shape[0] or s2[0][1] < 0 or s2[0][1] > self.game_shape[1]:\r\n                p2_collision = 1\r\n\r\n        if s1[0] in s2:\r\n            p1_collision = 1\r\n        if s2[0] in s1:\r\n            p2_collision = 1\r\n        return p1_collision, p2_collision\r\n\r\n    def check_food(self, s1, s2, food):\r\n\r\n        while True:\r\n            new_food = (random.randint(0, self.game_shape[0]-1), random.randint(0, self.game_shape[0]-1))\r\n            if new_food not in s1 and new_food not in s2:\r\n                break\r\n        if s1:\r\n            if s1[0] == food:\r\n                return True, False, new_food\r\n        if s2:\r\n            if s2[0] == food:\r\n                return False, True, new_food\r\n\r\n        return False, False, food\r\n\r\n\r\ndef main():\r\n    \"\"\" Create a UDP Server and handle multiple clients simultaneously \"\"\"\r\n\r\n    udp_server_multi_client = UDPServer('0.0.0.0', 10000)\r\n    udp_server_multi_client.configure_server()\r\n    while True:\r\n        udp_server_multi_client.wait_for_client()\r\n\r\n\r\nif __name__ == '__main__':\r\n    main()
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/server/server.py b/src/server/server.py
--- a/src/server/server.py	(revision 27b6ca549dc6c74a830d110fe0554b6d1ed57fe0)
+++ b/src/server/server.py	(date 1623420959258)
@@ -108,7 +108,7 @@
             return {
                 "sender": 0,
                 "message_type": 4,
-                "success": 500
+                "response": 500
             }
 
         game_info_list = []
@@ -122,7 +122,7 @@
             "message_type": 4,
             "number_of_games": len(game_info_list),
             "list_of_games": game_info_list,
-            "success": 200
+            "response": 200
         }
 
     def join_game(self, req):
@@ -171,13 +171,13 @@
                 "sender": 0,
                 "message_type": 12,
                 "game_state": self.games[req["game_id"]],
-                "success": 200
+                "response": 200
             }
         else:
             return {
                 "sender": 0,
                 "message_type": 12,
-                "success": 500
+                "response": 500
             }
 
     def create_game(self, req):
@@ -234,11 +234,11 @@
                 current_game["d2"] = req["d"]
         else:
             return {
-                "success": 500
+                "response": 500
             }
 
         return {
-            "sucess": 200
+            "response": 200
         }
 
     @staticmethod
